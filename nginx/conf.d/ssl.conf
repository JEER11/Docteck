## TLS/HTTPS configuration template
#
# How to enable:
# 1) Obtain valid certs (Letâ€™s Encrypt or your CA) and place them under ./certs (mounted to /etc/nginx/certs)
# 2) In docker-compose.yml, uncomment the 443 port mapping and the certs volume
# 3) Replace server_name below with your real domains and uncomment both server blocks
# 4) Deploy, confirm HTTPS works, then keep HSTS enabled

# --- PRODUCTION TLS SERVER (enabled) ---
server {
	listen 443 ssl http2;
	server_name yourdomain.com www.yourdomain.com;  # TODO: replace with real domain(s)

	ssl_certificate     /etc/nginx/certs/fullchain.pem;   # e.g., /etc/letsencrypt/live/yourdomain.com/fullchain.pem
	ssl_certificate_key /etc/nginx/certs/privkey.pem;     # e.g., /etc/letsencrypt/live/yourdomain.com/privkey.pem
	ssl_session_timeout 1d;
	ssl_protocols TLSv1.2 TLSv1.3;
	ssl_ciphers 'ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256';
	ssl_prefer_server_ciphers off;

	# HSTS (enable after confirming HTTPS works)
	add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;

	# Security headers (mirror/update from nginx.conf)
	add_header X-Content-Type-Options "nosniff" always;
	add_header Referrer-Policy "strict-origin-when-cross-origin" always;
	add_header X-Frame-Options "SAMEORIGIN" always;
	add_header Permissions-Policy "geolocation=(), camera=(), microphone=(), payment=()" always;
	# CSP: use same Report-Only policy as port 80 or switch to enforce after audit
	add_header Content-Security-Policy-Report-Only "\
		default-src 'self'; \
		img-src 'self' data: blob: https:; \
		media-src 'self' data: blob: https:; \
		style-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net https://fonts.googleapis.com; \
		font-src 'self' data: https://cdn.jsdelivr.net https://fonts.gstatic.com; \
		script-src 'self' 'unsafe-inline' 'unsafe-eval' https://js.stripe.com https://apis.google.com https://www.gstatic.com https://www.google.com https://cdn.jsdelivr.net; \
		connect-src 'self' data: wss: https://api.stripe.com https://js.stripe.com https://firestore.googleapis.com https://firebasestorage.googleapis.com https://firebase.googleapis.com https://identitytoolkit.googleapis.com https://securetoken.googleapis.com https://api.openweathermap.org https://openweathermap.org; \
		frame-src 'self' https://js.stripe.com https://hooks.stripe.com https://www.google.com; \
		frame-ancestors 'self';" always;

	# Static React assets (optional direct serve)
	location /app/static/ {
		alias /usr/share/nginx/html/static/;
		access_log off;
		expires 30d;
		add_header Cache-Control "public";
	}

	# Proxy SPA and app pages to Flask
	location /app/ {
		proxy_pass http://flask_upstream;
		proxy_http_version 1.1;
		proxy_set_header Connection "";
		proxy_set_header Host $host;
		proxy_set_header X-Real-IP $remote_addr;
		proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
		proxy_set_header X-Forwarded-Proto $scheme;
		proxy_read_timeout 75s;
	}

	# Backend API (Node)
	location /api/ {
		proxy_pass http://node_upstream;
		proxy_http_version 1.1;
		proxy_set_header Connection "";
		proxy_set_header Host $host;
		proxy_set_header X-Real-IP $remote_addr;
		proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
		proxy_set_header X-Forwarded-Proto $scheme;
		if ($request_method = 'OPTIONS') {
			add_header 'Access-Control-Allow-Origin' '*';
			add_header 'Access-Control-Allow-Methods' 'GET, POST, PUT, PATCH, DELETE, OPTIONS';
			add_header 'Access-Control-Allow-Headers' 'Authorization, Content-Type, X-Requested-With';
			return 204;
		}
	}

	# Uploads and generated assets (Flask)
	location /uploads/ {
		proxy_pass http://flask_upstream;
		proxy_http_version 1.1;
		proxy_set_header Connection "";
		proxy_set_header Host $host;
		proxy_set_header X-Real-IP $remote_addr;
		proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
		proxy_set_header X-Forwarded-Proto $scheme;
	}

	# Root convenience redirect to SPA
	location = / { return 302 /app/dashboard; }
}

# --- HTTP -> HTTPS REDIRECT (uncomment when TLS server above is enabled) ---
# server {
#   listen 80;
#   server_name yourdomain.com www.yourdomain.com;
#   return 301 https://$host$request_uri;
# }
